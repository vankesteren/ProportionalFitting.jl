<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ProportionalFitting.jl</title><meta name="title" content="Home · ProportionalFitting.jl"/><meta property="og:title" content="Home · ProportionalFitting.jl"/><meta property="twitter:title" content="Home · ProportionalFitting.jl"/><meta name="description" content="Documentation for ProportionalFitting.jl."/><meta property="og:description" content="Documentation for ProportionalFitting.jl."/><meta property="twitter:description" content="Documentation for ProportionalFitting.jl."/><meta property="og:url" content="https://vankesteren.github.io/ProportionalFitting.jl/"/><meta property="twitter:url" content="https://vankesteren.github.io/ProportionalFitting.jl/"/><link rel="canonical" href="https://vankesteren.github.io/ProportionalFitting.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ProportionalFitting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Inconsistent-margins"><span>Inconsistent margins</span></a></li><li><a class="tocitem" href="#Multidimensional-arrays"><span>Multidimensional arrays</span></a></li><li><a class="tocitem" href="#Multidimensional-margins"><span>Multidimensional margins</span></a></li><li><a class="tocitem" href="#Repeated-margins"><span>Repeated margins</span></a></li></ul></li><li><a class="tocitem" href="examples/">Examples</a></li><li><a class="tocitem" href="benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/vankesteren/ProportionalFitting.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ProportionalFitting"><a class="docs-heading-anchor" href="#ProportionalFitting">ProportionalFitting</a><a id="ProportionalFitting-1"></a><a class="docs-heading-anchor-permalink" href="#ProportionalFitting" title="Permalink"></a></h1><p>Multidimensional iterative proportional fitting in Julia. </p><p><a href="https://github.com/vankesteren/ProportionalFitting.jl">ProportionalFitting</a> implements a multidimensional version of the <a href="https://en.wikipedia.org/wiki/Iterative_proportional_fitting#Algorithm_2_(factor_estimation)">factor estimation method</a> for performing iterative proportional fitting (also called RAS algorithm, raking, matrix scaling). </p><p>In the two-dimensional case, iterative proportional fitting means changing a matrix <span>$X$</span> to have marginal sum totals <span>$u, v$</span>. One prime use is in survey data analysis, where <span>$X$</span> could be your data&#39;s cross-tabulation of demographic characteristics, and <span>$u, v$</span> the known population proportions of those characteristics.</p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>Assume you have a matrix <code>X</code>:</p><pre><code class="language-julia hljs">X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Int64}:
 40  30   20   10
 35  50  100   75
 30  80   70  120
 20  30   40   50</code></pre><p>And the row and column margins of another matrix <code>Y</code> (<code>u</code> and <code>v</code>, respectively) but not the full matrix:</p><pre><code class="language-julia hljs">u = [150, 300, 400, 150]
v = [200, 300, 400, 100]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
 200
 300
 400
 100</code></pre><p>Then the <code>ipf</code> function from ProportionalFitting will find the array factors which adjust matrix <code>X</code> to have the margins <code>u</code> and <code>v</code>:</p><pre><code class="language-julia hljs">fac = ipf(X, [u, v])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Factors for 2D array:
  [1]: [0.9986403503185242, 0.8833622306385376, 1.1698911437112522, 0.8895042701910321]
  [2]: [1.616160156063788, 1.5431801747375655, 1.771623700829941, 0.38299396265192226]</code></pre><p>Array factors (<code>ArrayFactors</code>) are a specific type exported by ProportionalFitting with a few methods, for example <code>Array()</code>:</p><pre><code class="language-julia hljs">Array(fac)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Float64}:
 1.61396  1.54108  1.76921  0.382473
 1.42765  1.36319  1.56499  0.338322
 1.89073  1.80535  2.07261  0.448061
 1.43758  1.37267  1.57587  0.340675</code></pre><p>To create the adjusted matrix <code>Z</code> with the margins <code>u</code> and <code>v</code>, we perform elementwise multiplication of this matrix with <code>X</code>:</p><pre><code class="language-julia hljs">Z = Array(fac) .* X</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Float64}:
 64.5585   46.2325   35.3843   3.82473
 49.9679   68.1594  156.499   25.3742
 56.7219  144.428   145.082   53.7673
 28.7516   41.18     63.0347  17.0337</code></pre><p>We can then check that the marginal sum totals are correct:</p><pre><code class="language-julia hljs">ArrayMargins(Z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Margins of 2D array:
  [1]: [150.0000000009452, 299.99999999962523, 399.99999999949796, 149.99999999993148]
  [2]: [200.0, 299.99999999999994, 399.99999999999994, 99.99999999999997]</code></pre><h2 id="Inconsistent-margins"><a class="docs-heading-anchor" href="#Inconsistent-margins">Inconsistent margins</a><a id="Inconsistent-margins-1"></a><a class="docs-heading-anchor-permalink" href="#Inconsistent-margins" title="Permalink"></a></h2><p>If the margins are inconsistent (i.e., the margins do not sum to the same amounts) then both <code>X</code> and the margins will be transformed to proportions.</p><pre><code class="language-julia hljs">m = ArrayMargins([[12, 23, 14, 35], [17, 44, 12, 33]])
af = ipf(X, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Factors for 2D array:
  [1]: [1.0426463240564372, 0.9297504397571145, 0.41888533101520664, 2.4187234600325582]
  [2]: [0.949061653550789, 1.8063342017380022, 0.3775175481010491, 0.9908356392601086]</code></pre><p>Then, <code>Z</code> needs to be computed in a different way as well:</p><pre><code class="language-julia hljs">X_prop = X ./ sum(X)
Z = X_prop .* Array(af)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Float64}:
 0.0494768  0.0706263  0.00984043  0.0129136
 0.0386046  0.104965   0.0438746   0.0863653
 0.0149081  0.0756647  0.0138369   0.062257
 0.0573879  0.163838   0.0456555   0.149785</code></pre><h2 id="Multidimensional-arrays"><a class="docs-heading-anchor" href="#Multidimensional-arrays">Multidimensional arrays</a><a id="Multidimensional-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimensional-arrays" title="Permalink"></a></h2><p>ProportionalFitting can also deal with multidimensional arrays of arbitrary shape. For example, consider the following <code>(3, 2, 3)</code> array and target margins:</p><pre><code class="language-julia hljs">X = reshape(1:12, 2, 3, 2)
m = [[48, 60], [28, 36, 44], [34, 74]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Int64}}:
 [48, 60]
 [28, 36, 44]
 [34, 74]</code></pre><p>Now we can run <code>ipf</code> to compute the adjustment:</p><pre><code class="language-julia hljs">fac = ipf(X, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Factors for 3D array:
  [1]: [0.7012649814229596, 0.7413620380098563]
  [2]: [1.59452605457307, 1.3830398765538434, 1.2753933840995484]
  [3]: [1.6474060813606772, 1.2880517029245548]</code></pre><p>And we can create the adjusted array <code>Z</code>:</p><pre><code class="language-julia hljs">Array(fac) .* X</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3×2 Array{Float64, 3}:
[:, :, 1] =
 1.84211  4.79335  7.36711
 3.89487  6.75656  9.34601

[:, :, 2] =
 10.082   11.2433  12.6722
 12.1811  13.2068  14.6147</code></pre><h2 id="Multidimensional-margins"><a class="docs-heading-anchor" href="#Multidimensional-margins">Multidimensional margins</a><a id="Multidimensional-margins-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimensional-margins" title="Permalink"></a></h2><p>ProportionalFitting can also deal with multidimensional margins of arbitrary shape. For example, consider the same <code>(3, 2, 3)</code> array as before:</p><pre><code class="language-julia hljs">X = reshape(1:12, 2, 3, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3×2 reshape(::UnitRange{Int64}, 2, 3, 2) with eltype Int64:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12</code></pre><p>We have multidimensional target margins (a 1D vector and a 2D matrix):</p><pre><code class="language-julia hljs">m1 = [48, 60]
m2 = [9 11 14; 19 25 30]
mar = [m1, m2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Array{Int64}}:
 [48, 60]
 [9 11 14; 19 25 30]</code></pre><p>Here, <code>m1</code> belongs to the first dimension of target matrix, and <code>m2</code> belongs to the third and second dimension (in that order). This can be encoded in a <code>DimIndices</code> object as follows:</p><pre><code class="language-julia hljs">dimid = DimIndices([1, [3, 2]])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Indices for 3D array:
[1][3, 2]</code></pre><p>Together, the margins and dimension indices they belong to constitute an <code>ArrayMargins</code> object:</p><pre><code class="language-julia hljs">m = ArrayMargins(mar, dimid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Margins of 3D array:
  [1]: [48, 60]
  [3, 2]: [9 11 14; 19 25 30]</code></pre><p>Now we can run <code>ipf</code> to compute the adjustment:</p><pre><code class="language-julia hljs">fac = ipf(X, m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Factors for 3D array:
  [1]: [0.9767649889221948, 1.0193941000886413]
  [3, 2]: [2.9845270289155916 1.569663514602841 1.272705342262194; 1.2672996639944127 1.3168411514607572 1.3056452924080841]</code></pre><p>And we can create the adjusted array <code>Z</code>:</p><pre><code class="language-julia hljs">Z = Array(fac) .* X</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3×2 Array{Float64, 3}:
[:, :, 1] =
 2.91518  4.59958  6.21567
 6.08482  6.40042  7.78433

[:, :, 2] =
  8.66498  11.5762  14.0284
 10.335    13.4238  15.9716</code></pre><p>We then also use <code>ArrayMargins</code> to check whether the margins of this array are indeed as expected!</p><pre><code class="language-julia hljs">ArrayMargins(Z, dimid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Margins of 3D array:
  [1]: [48.000000000010544, 59.99999999998945]
  [3, 2]: [9.0 11.0 14.000000000000002; 19.0 24.999999999999996 30.0]</code></pre><h2 id="Repeated-margins"><a class="docs-heading-anchor" href="#Repeated-margins">Repeated margins</a><a id="Repeated-margins-1"></a><a class="docs-heading-anchor-permalink" href="#Repeated-margins" title="Permalink"></a></h2><p>With multidimensional margins, it is also possible to enter a single margin multiple times in different target margins. This is allowed as long as the margin totals match, and as long as no two target margins are about the exact same dimensions. For example:</p><pre><code class="language-julia hljs"># Create a 2×3×4 array with seed value 1
initial_array = ones(2, 3, 4)

# Specify target margins for dimensions 1 and 3
tgt_13 = [
    10.0 15.0 20.0 25.0;
    30.0 35.0 40.0 45.0
]

# Specify target margins for dimensions 2 and 3
tgt_23 = [
    12.0 16.0 20.0 24.0;
    18.0 22.0 26.0 30.0;
    10.0 12.0 14.0 16.0
]

# dimension 3 occurs twice!
target_dims = [[1, 3], [2, 3]]
target_margins = [tgt_13, tgt_23]

# at this point, the margins are checked for consistency
AM = ArrayMargins(target_margins, target_dims)

# We can run ipf with these duplicated margins
AF = ipf(initial_array, AM)

# check that the margins are as specified
ArrayMargins(Array(AF), target_dims)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Margins of 3D array:
  [1, 3]: [10.0 14.999999999999998 20.0 25.0; 30.0 35.0 40.0 45.00000000000001]
  [2, 3]: [12.0 16.0 20.0 24.0; 18.0 22.0 26.0 30.000000000000004; 10.0 11.999999999999998 13.999999999999998 16.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Friday 30 May 2025 01:49">Friday 30 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
