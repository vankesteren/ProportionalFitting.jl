var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks below were run on Julia version 1.11.5.","category":"page"},{"location":"benchmarks/#Default-example","page":"Benchmarks","title":"Default example","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]\nu = [150, 300, 400, 150]\nv = [200, 300, 400, 100]\n@benchmark ipf(X, [u, v])","category":"page"},{"location":"benchmarks/#Large-contingency-table","page":"Benchmarks","title":"Large contingency table","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = reshape(repeat(1:16, 625), 100, 100)\nY = reshape(repeat(1:5, 2000), 100, 100) + X\nm = ArrayMargins(Y)\n@benchmark ipf(X, m)","category":"page"},{"location":"benchmarks/#Six-dimensional-contingency-table","page":"Benchmarks","title":"Six-dimensional contingency table","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = reshape(repeat(1:12, 100), 6, 4, 2, 5, 5)\nY = reshape(repeat(1:5, 240), 6, 4, 2, 5, 5) + X\nm = ArrayMargins(Y)\n@benchmark ipf(X, m)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Regression-poststratification","page":"Examples","title":"Regression poststratification","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StatsKit, FreqTables, ProportionalFitting","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we generate some fake data with demographic characteristics.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"N = 100\np_sex = Categorical([0.49, 0.51])\np_edu = Categorical([0.1, 0.3, 0.4, 0.2])\np_age = Categorical([0.1, 0.3, 0.3, 0.2, 0.1])\np_inc = LogNormal(5, 3)\np_opn = Normal(0, 3)\ndf = DataFrame(\n    :sex => CategoricalArray([\"m\", \"f\"][rand(p_sex, N)]),\n    :edu => CategoricalArray([\"no\", \"lo\", \"med\", \"hi\"][rand(p_edu, N)], ordered = true),\n    :age => CategoricalArray([\"<10\", \"11<25\", \"26<50\", \"51<70\", \">70\"][rand(p_age, N)], ordered = true),\n    :inc => rand(p_inc, N)\n)\ndf.opn = 1.5 .+ log.(df.inc) .* .1 + rand(p_opn, N)\n\n# show the first 6 rows\nfirst(df, 6)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then, we create post-stratification weights based on population-level margins using the background characteristics through ProportionalFitting.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create a cross-table of background characteristics\ntab = freqtable(df, :sex, :edu, :age)\n\n# Create margins from the population (aggregates obtained from statistical agency)\npop_margins = ArrayMargins([[0.49, 0.51], [0.05, 0.2, 0.5, 0.25], [0.1, 0.2, 0.4, 0.15, 0.15]])\n\n# Compute array factors\nfac = ipf(Array(tab), pop_margins)\n\n# Compute adjusted table\ntab_adj = Array(fac) .* tab","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Create weights by looking up the adjusted counts and then performing normalization.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create a poststratification weight variable by lookup from the table\ndf.w = [tab_adj[row...] for row in eachrow(df[:, [:sex, :edu, :age]])]\ndf.w = df.w ./ sum(df.w) .* N # normalize the weights","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's take a look at how our regression estimates change!","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# perform unweighted regression\nfrm = @formula(opn ~ log(inc))\nres = lm(frm, df)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# perform weighted regression\nres_w = lm(frm, df, wts = df.w)","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Core.Array-Union{Tuple{ArrayFactors{T}}, Tuple{T}} where T","page":"Reference","title":"Core.Array","text":"Array(AF::ArrayFactors{T})\n\nCreate an array out of an ArrayFactors object.\n\nArguments\n\nA::ArrayFactors{T}: Array factors\n\nExamples\n\njulia> fac = ArrayFactors([[1,2,3], [4,5], [6,7]])\nFactors for array of size (3, 2, 2):\n    1: [1, 2, 3]\n    2: [4, 5]\n    3: [6, 7]\n\njulia> Array(fac)\n3×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 24  30\n 48  60\n 72  90\n\n[:, :, 2] =\n 28   35\n 56   70\n 84  105\n\n\n\n\n\n","category":"method"},{"location":"reference/#ProportionalFitting.ArrayFactors","page":"Reference","title":"ProportionalFitting.ArrayFactors","text":"ArrayFactors(af::Vector{<:AbstractArray}, di::DimIndices)\nArrayFactors(af::Vector{<:AbstractArray}, di::Vector)\nArrayFactors(af::Vector{<:AbstractArray})\n\nArray factors are defined such that the array's elements are their products: M[i, j, ..., l] = af[1][i] * af[2][j] * ... * af[3][l].\n\nThe array factors can be vectors or multidimensional arrays themselves.\n\nThe main use of ArrayFactors is as a memory-efficient representation of a multidimensional array, which can be constructed using the Array() method.\n\nsee also: ipf, ArrayMargins, DimIndices\n\nFields\n\naf::Vector{<:AbstractArray}: Vector of (multidimensional) array factors\ndi::DimIndices: Dimension indices to which the array factors belong.\n\nExamples\n\njulia> AF = ArrayFactors([[1,2,3], [4,5]])\nFactors for array of size (3, 2):\n  [1]: [1, 2, 3]\n  [2]: [4, 5]\n\njulia> eltype(AF)\nInt64\n\njulia> Array(AF)\n3×2 Matrix{Int64}:\n  4   5\n  8  10\n 12  15\n\njulia> AF = ArrayFactors([[1,2,3], [4 5; 6 7]], DimIndices([2, [1, 3]]))\nFactors for 3D array:\n  [2]: [1, 2, 3]\n  [1, 3]: [4 5; 6 7]\n\njulia> Array(AF)\n2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 4   8  12\n 6  12  18\n\n[:, :, 2] =\n 5  10  15\n 7  14  21\n\n\n\n\n\n","category":"type"},{"location":"reference/#ProportionalFitting.ArrayMargins","page":"Reference","title":"ProportionalFitting.ArrayMargins","text":"ArrayMargins(am::Vector{<:AbstractArray}, di::DimIndices)\nArrayMargins(am::Vector{<:AbstractArray}, di::Vector)\nArrayMargins(am::Vector{<:AbstractArray})\nArrayMargins(X::AbstractArray, di::DimIndices)\nArrayMargins(X::AbstractArray)\n\nArrayMargins are marginal sums of an array, combined with the indices of the dimensions these sums belong to. The marginal sums can be multidimensional arrays themselves.\n\nThere are various constructors for ArrayMargins, based on either raw margins or an actual array from which the margins are then computed.\n\nsee also: DimIndices, ArrayFactors, ipf\n\nFields\n\nam::Vector{AbstractArray}: Vector of marginal sums.\ndi::DimIndices: Dimension indices to which the elements of am belong.\n\nExamples\n\njulia> X = reshape(1:12, 2, 3, 2)\n2×3×2 reshape(::UnitRange{Int64}, 2, 3, 2) with eltype Int64:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\njulia> ArrayMargins(X)\nMargins from 3D array:\n  [1]: [36, 42]\n  [2]: [18, 26, 34]\n  [3]: [21, 57]\n\njulia> ArrayMargins(X, [1, [2, 3]])\nMargins from 3D array:\n  [1]: [36, 42]\n  [2, 3]: [3 15; 7 19; 11 23]\n\njulia> ArrayMargins(X, [2, [3, 1]])\nMargins of 3D array:\n  [2]: [18, 26, 34]\n  [3, 1]: [9 12; 27 30]\n\n\n\n\n\n","category":"type"},{"location":"reference/#ProportionalFitting.DimIndices","page":"Reference","title":"ProportionalFitting.DimIndices","text":"DimIndices(idx::Vector{Vector{Int}})\n\nDimIndices represent an exhaustive list of indices for the  dimensions of an array. It is an object containing a single element, idx, which is a nested vector of integers;  e.g., [[2], [1, 3], [4]]. DimIndices objects are checked for  uniqueness and completeness, i.e., all indices up to the largest index are used exactly once.\n\nFields\n\nidx::Vector{Vector{Int}}: nested vector of dimension indices.\n\nExamples\n\njulia> DimIndices([2, [1, 3], 4])\nIndices for 4D array:\n[[2], [1, 3], [4]]\n\n\n\n\n\n","category":"type"},{"location":"reference/#ProportionalFitting.default_dimindices-Tuple{Vector{<:AbstractArray}}","page":"Reference","title":"ProportionalFitting.default_dimindices","text":"default_dimindices(m::Vector{<:AbstractArray})\n\nCreate default dimensions from a vector of arrays. These dimensions are assumed to be ordered. For example, for  the dimensions will be [[1], [2], [3]]. For [[1, 2], [2 1 ; 3 4]], it will be [[1], [2, 3]].\n\nSee also: DimIndices\n\nArguments\n\nm::Vector{<:AbstractArray}: Array margins or factors.\n\nExamples\n\njulia> default_dimindices([[1, 2], [2, 1], [3, 4]])\nIndices for 3D array:\n    [[1], [2], [3]]\n\njulia> default_dimindices([[1, 2], [2 1 ; 3 4]])\nIndices for 3D array:\n    [[1], [2, 3]]\n\n\n\n\n\n","category":"method"},{"location":"reference/#ProportionalFitting.ipf-Tuple{AbstractArray{<:Real}, ArrayMargins}","page":"Reference","title":"ProportionalFitting.ipf","text":"ipf(X::AbstractArray{<:Real}, mar::ArrayMargins; maxiter::Int = 1000, tol::Float64 = 1e-10)\nipf(X::AbstractArray{<:Real}, mar::Vector{<:Vector{<:Real}})\nipf(mar::ArrayMargins)\nipf(mar::Vector{<:Vector{<:Real}})\n\nPerform iterative proportional fitting (factor method). The array (X) can be any number of dimensions, and the margins can be multidimensional as well.  If only the margins are given, then the seed array X is assumed to be an array filled with ones of the correct size and element type.\n\nIf the margins are not an ArrayMargins object, they will be coerced to this type.\n\nThis function returns the update matrix as an ArrayFactors object. To compute the updated matrix, use Array(result) .* X (see examples).\n\nIf decreasing memory usage is a concern, it is possible to set precision to be lower     than Float64. It is also possible to decrease memory usage (by up to almost 50%) by     supplying X as an an object of type Array{precision}.\n\nsee also: ArrayFactors, ArrayMargins\n\nArguments\n\nX::AbstractArray{<:Real}: Array to be adjusted\nmar::ArrayMargins: Target margins as an ArrayMargins object\nmaxiter::Int=1000: Maximum number of iterations\nprecision::DataType=Float64: The numeric precision to which calculations are   carried out. Note that there is no bounds checking, however. Must be <:AbstractFloat.\ntol=1e-10: Factor change tolerance for convergence\n\nExamples\n\njulia> X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]\njulia> u = [150, 300, 400, 150]\njulia> v = [200, 300, 400, 100]\njulia> AF = ipf(X, [u, v])\nFactors for 2D array:\n    [1]: [0.9986403503185242, 0.8833622306385376, 1.1698911437112522, 0.8895042701910321]\n    [2]: [1.616160156063788, 1.5431801747375655, 1.771623700829941, 0.38299396265192226]\n\njulia> Z = Array(AF) .* X\n4×4 Matrix{Float64}:\n 64.5585   46.2325   35.3843   3.82473\n 49.9679   68.1594  156.499   25.3742\n 56.7219  144.428   145.082   53.7673\n 28.7516   41.18     63.0347  17.0337\n\njulia> ArrayMargins(Z)\nMargins of 2D array:\n  [1]: [150.0000000009452, 299.99999999962523, 399.99999999949796, 149.99999999993148]\n  [2]: [200.0, 299.99999999999994, 399.99999999999994, 99.99999999999997]\n\n\n\n\n\n","category":"method"},{"location":"#ProportionalFitting","page":"Home","title":"ProportionalFitting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multidimensional iterative proportional fitting in Julia. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ProportionalFitting implements a multidimensional version of the factor estimation method for performing iterative proportional fitting (also called RAS algorithm, raking, matrix scaling). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the two-dimensional case, iterative proportional fitting means changing a matrix X to have marginal sum totals u v. One prime use is in survey data analysis, where X could be your data's cross-tabulation of demographic characteristics, and u v the known population proportions of those characteristics.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Assume you have a matrix X:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]","category":"page"},{"location":"","page":"Home","title":"Home","text":"And the row and column margins of another matrix Y (u and v, respectively) but not the full matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"u = [150, 300, 400, 150]\nv = [200, 300, 400, 100]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the ipf function from ProportionalFitting will find the array factors which adjust matrix X to have the margins u and v:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fac = ipf(X, [u, v])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array factors (ArrayFactors) are a specific type exported by ProportionalFitting with a few methods, for example Array():","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array(fac)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To create the adjusted matrix Z with the margins u and v, we perform elementwise multiplication of this matrix with X:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Z = Array(fac) .* X","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then check that the marginal sum totals are correct:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayMargins(Z)","category":"page"},{"location":"#Inconsistent-margins","page":"Home","title":"Inconsistent margins","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the margins are inconsistent (i.e., the margins do not sum to the same amounts) then both X and the margins will be transformed to proportions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"m = ArrayMargins([[12, 23, 14, 35], [17, 44, 12, 33]])\naf = ipf(X, m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, Z needs to be computed in a different way as well:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X_prop = X ./ sum(X)\nZ = X_prop .* Array(af)","category":"page"},{"location":"#Multidimensional-arrays","page":"Home","title":"Multidimensional arrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ProportionalFitting can also deal with multidimensional arrays of arbitrary shape. For example, consider the following (3, 2, 3) array and target margins:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = reshape(1:12, 2, 3, 2)\nm = [[48, 60], [28, 36, 44], [34, 74]]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can run ipf to compute the adjustment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fac = ipf(X, m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And we can create the adjusted array Z:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array(fac) .* X","category":"page"},{"location":"#Multidimensional-margins","page":"Home","title":"Multidimensional margins","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ProportionalFitting can also deal with multidimensional margins of arbitrary shape. For example, consider the same (3, 2, 3) array as before:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = reshape(1:12, 2, 3, 2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have multidimensional target margins (a 1D vector and a 2D matrix):","category":"page"},{"location":"","page":"Home","title":"Home","text":"m1 = [48, 60]\nm2 = [9 11 14; 19 25 30]\nmar = [m1, m2]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, m1 belongs to the first dimension of target matrix, and m2 belongs to the third and second dimension (in that order). This can be encoded in a DimIndices object as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"dimid = DimIndices([1, [3, 2]])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Together, the margins and dimension indices they belong to constitute an ArrayMargins object:","category":"page"},{"location":"","page":"Home","title":"Home","text":"m = ArrayMargins(mar, dimid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can run ipf to compute the adjustment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fac = ipf(X, m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And we can create the adjusted array Z:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Z = Array(fac) .* X","category":"page"},{"location":"","page":"Home","title":"Home","text":"We then also use ArrayMargins to check whether the margins of this array are indeed as expected!","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayMargins(Z, dimid)","category":"page"},{"location":"#Repeated-margins","page":"Home","title":"Repeated margins","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With multidimensional margins, it is also possible to enter a single margin multiple times in different target margins. This is allowed as long as the margin totals match, and as long as no two target margins are about the exact same dimensions. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Create a 2×3×4 array with seed value 1\ninitial_array = ones(2, 3, 4)\n\n# Specify target margins for dimensions 1 and 3\ntgt_13 = [\n    10.0 15.0 20.0 25.0;\n    30.0 35.0 40.0 45.0\n]\n\n# Specify target margins for dimensions 2 and 3\ntgt_23 = [\n    12.0 16.0 20.0 24.0;\n    18.0 22.0 26.0 30.0;\n    10.0 12.0 14.0 16.0\n]\n\n# dimension 3 occurs twice!\ntarget_dims = [[1, 3], [2, 3]]\ntarget_margins = [tgt_13, tgt_23]\n\n# at this point, the margins are checked for consistency\nAM = ArrayMargins(target_margins, target_dims)\n\n# We can run ipf with these duplicated margins\nAF = ipf(initial_array, AM)\n\n# check that the margins are as specified\nArrayMargins(Array(AF), target_dims)","category":"page"}]
}
